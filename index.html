<!DOCTYPE html>
<html lang="en">
<head>
    <meta charset="UTF-8">
    <meta name="viewport" content="width=device-width, initial-scale=1.0, maximum-scale=1.0">
    <title>VG Viewer</title>
    <style>
        body {
            background: #000;
            margin: 0;
            padding: 0;
            overflow: hidden;
            display: flex;
            font-family: Arial, sans-serif;
        }
        #directory-panel {
            width: 250px;
            background: #1a1a1a;
            color: #fff;
            padding: 10px;
            overflow-y: auto;
            height: 100vh;
            border-right: 1px solid #333;
            flex-shrink: 0;
        }
        #viewer-container {
            flex: 1;
            height: 100vh;
            position: relative;
            display: flex;
        }
        #openseadragon1 {
            flex: 1;
            position: relative;
        }
        #right-panel {
            width: 250px;
            background: #1a1a1a;
            border-left: 1px solid #333;
            padding: 15px;
            flex-shrink: 0;
        }

        /* Directory styles */
        .search-container {
            margin-bottom: 10px;
            padding: 5px;
        }
        #directory-search {
            width: 100%;
            padding: 5px;
            background: #333;
            border: 1px solid #444;
            color: #fff;
            border-radius: 3px;
        }
        .directory-tree {
            list-style: none;
            padding: 0;
            margin: 0;
        }
        .directory-item {
            padding: 4px 0;
            cursor: pointer;
            display: flex;
            align-items: center;
            gap: 5px;
        }
        .directory-item:hover {
            background: #2a2a2a;
        }
        .folder-icon::before {
            content: "üìÅ";
        }
        .folder-open-icon::before {
            content: "üìÇ";
        }
        .file-icon::before {
            content: "üñºÔ∏è";
        }
        .folder-contents {
            margin-left: 20px;
            display: none;
        }
        .folder-contents.open {
            display: block;
        }
        .folder-toggle {
            width: 16px;
            height: 16px;
            display: inline-block;
            text-align: center;
            line-height: 16px;
            cursor: pointer;
        }

        /* Control styles */
        .control-section {
            margin-bottom: 20px;
        }
        .section-title {
            font-size: 14px;
            color: #999;
            margin-bottom: 15px;
            padding-bottom: 5px;
            border-bottom: 1px solid #333;
        }
        .control-group {
            margin-bottom: 15px;
            color: white;
        }
        .control-label {
            display: flex;
            justify-content: space-between;
            margin-bottom: 5px;
            font-size: 12px;
        }
        .slider-container {
            display: flex;
            align-items: center;
            gap: 10px;
        }
        input[type="range"] {
            flex-grow: 1;
            -webkit-appearance: none;
            width: 100%;
            height: 4px;
            border-radius: 2px;
            background: #444;
            outline: none;
        }
        input[type="range"]::-webkit-slider-thumb {
            -webkit-appearance: none;
            width: 12px;
            height: 12px;
            border-radius: 50%;
            background: #2196F3;
            cursor: pointer;
        }
        input[type="number"] {
            width: 45px;
            background: #333;
            border: 1px solid #444;
            color: white;
            border-radius: 3px;
            padding: 2px 4px;
            font-size: 12px;
        }
        .reset-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
        }

        /* Add new styles for the invert control */
        .invert-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }
        
        .invert-control {
            display: flex;
            align-items: center;
            gap: 8px;
            color: white;
            font-size: 12px;
        }

        input[type="checkbox"] {
            width: 16px;
            height: 16px;
            background: #333;
            border: 1px solid #444;
            border-radius: 3px;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            position: relative;
        }

        input[type="checkbox"]:checked {
            background: #2196F3;
            border-color: #2196F3;
        }

        input[type="checkbox"]:checked::after {
            content: '‚úì';
            position: absolute;
            color: white;
            font-size: 12px;
            left: 2px;
            top: -1px;
        }


        /* Add styles for edge enhancement controls */
        .edge-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #333;
            color: white;
        }

        .edge-title {
            font-size: 12px;
            margin-bottom: 10px;
        }

        .edge-options {
            display: flex;
            flex-direction: column;
            gap: 8px;
        }

        .edge-option {
            display: flex;
            align-items: center;
            gap: 8px;
        }

        input[type="radio"] {
            width: 16px;
            height: 16px;
            background: #333;
            border: 1px solid #444;
            border-radius: 50%;
            cursor: pointer;
            appearance: none;
            -webkit-appearance: none;
            position: relative;
        }

        input[type="radio"]:checked {
            border-color: #2196F3;
        }

        input[type="radio"]:checked::after {
            content: '';
            position: absolute;
            width: 8px;
            height: 8px;
            background: #2196F3;
            border-radius: 50%;
            left: 50%;
            top: 50%;
            transform: translate(-50%, -50%);
        }

        .edge-option label {
            font-size: 12px;
            cursor: pointer;
        }

        /* Adding Scalebar with default color */
        .scalebar {
            position: absolute;
            bottom: 20px;
            right: 20px;
            background: rgba(0, 0, 0, 0.5);
            padding: 4px 8px;
            color: white;
            font-size: 12px;
            border-radius: 3px;
            z-index: 1000;
        }

        .measure-title {
            font-size: 12px;
            margin-bottom: 10px;
            color: white;
        }

        .measure-section {
            margin-top: 20px;
            padding-top: 15px;
            border-top: 1px solid #333;
        }

        .tool-button {
            background: #2196F3;
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 12px;
            width: 100%;
            margin-bottom: 10px;
        }

        .tool-button.active {
            background: #f44336;
        }

        /* Table list view (for demo, will change) */
        /*.table-list-container {
            position: absolute;
            top: 65px;
            left: 5px;
            background: rgba(26, 26, 26, 0.9);
            border-radius: 4px;
            padding: 10px;
            z-index: 1000;
            max-height: 80vh;
            overflow-y: auto;
            width: 670px;
            display: none;
        }
        
        .table-list {
            width: 100%;
            border-collapse: collapse;
            color: white;
            font-size: 15px;
        }
        
        .table-list td, .table-list th {
            padding: 6px;
            text-align: center;
            border-bottom: 1px solid #333;
        }
        
        .table-list td img {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 4px;
            cursor: pointer;
        }

        .table-list td {
            vertical-align: middle;
        }*/

        .table-list-container {
            position: absolute;
            top: 65px;
            left: 5px;
            background: rgba(26, 26, 26, 0.9);
            border-radius: 4px;
            padding: 0; /* Changed from 10px */
            z-index: 1000;
            max-height: 80vh;
            overflow: hidden; /* Changed from overflow-y: auto */
            width: 670px;
            display: none;
        }
        
        /* Header styles */
        .table-header-container {
            position: sticky;
            top: 0;
            z-index: 10;
            background: rgba(26, 26, 26, 1); /* Slightly darker than table background */
            border-bottom: 2px solid #333;
            padding: 10px 10px 0 10px;
        }
        
        /* Scrollable body container */
        .table-body-container {
            overflow-y: auto;
            max-height: calc(80vh - 55px); /* Adjust based on header height */
            padding: 0 10px 10px 10px;
        }
        
        /* Adjust table styles */
        .table-list {
            width: 100%;
            border-collapse: separate;
            border-spacing: 0;
            color: white;
            font-size: 15px;
        }
        
        .table-list th {
            position: relative;
            padding: 6px;
            text-align: center;
            background: rgba(26, 26, 26, 1);
        }
        
        .table-list td {
            padding: 6px;
            text-align: center;
            border-bottom: 1px solid #333;
        }
        
        .table-list tr:hover {
            background: rgba(33, 150, 243, 0.2);
            cursor: pointer;
        }
        
        .table-toggle {
            position: absolute;
            top: 35px;
            left: 5px;
            z-index: 1001;
            background: rgba(0, 0, 0, 0.7);
            color: white;
            border: none;
            padding: 8px 12px;
            border-radius: 4px;
            cursor: pointer;
            font-size: 15px;
        }

        .table-header {
            color: #999;
            font-weight: bold;
            border-bottom: 2px solid #333;
        }

       

        /* Export context menu styles */
        .custom-context-menu {
            display: none;
            position: fixed;
            background: #1a1a1a;
            border: 1px solid #333;
            border-radius: 4px;
            padding: 5px 0;
            min-width: 150px;
            box-shadow: 0 2px 5px rgba(0, 0, 0, 0.5);
            z-index: 1100;
        }

        .context-menu-item {
            padding: 8px 15px;
            color: white;
            cursor: pointer;
            font-size: 14px;
        }

        .context-menu-item:hover {
            background: #2196F3;
        }

        /* Add hover effect to table rows */
        .table-list tr {
            transition: background-color 0.2s;
        }

        .table-list tr:hover {
            background: rgba(33, 150, 243, 0.2);
        }

        /* Add selected state for rows */
        .table-list tr.selected {
            background: rgba(33, 150, 243, 0.3);
        }



        /* Expandable row styling */
        .expand-button {
            cursor: pointer;
            color: #2196F3;
            margin-right: 10px;
            display: inline-block;
            width: 25px;
            text-align: left;
            font-weight: bold;
        }
        
        .nested-row {
            display: none;
            background: rgba(26, 26, 26, 0.5);
        }
        
        .nested-row.visible {
            display: table-row;
        }
        
        .parent-row {
            background: rgba(45, 45, 45, 0.7);
        }
        
        
        /* Add indentation for nested rows */
        .nested-row td:first-child {
            padding-left: 35px !important; /* Add space for indentation */
        }

        .nested-row td {
            padding: 8px 6px;
            border-left: 2px solid rgba(33, 150, 243, 0.2); /* Add subtle vertical line */
        }

        /* Adjust expand button positioning */
        .expand-button {
            cursor: pointer;
            color: #2196F3;
            display: inline-block;
            width: 50px;
            text-align: center;
            font-weight: bold;
            position: absolute;
            left: -15px;
        }

        /* Container for thumbnail and expand button */
        .thumbnail-container {
            position: relative;
            padding-left: 25px; /* Make space for expand button */
            display: flex;
            align-items: center;
        }

        /* Update table cells to support new layout */
        .table-list td {
            position: relative;
        }

        /* Adjust thumbnail size if needed */
        .table-list td img {
            width: 50px;
            height: 50px;
            object-fit: cover;
            border-radius: 4px;
        }

        /* Add subtle connecting lines */
        .parent-row td {
            border-bottom: 2px solid rgba(33, 150, 243, 0.2);
        }

        .nested-row:last-child td {
            border-bottom: 1px solid #333;
        }
        /* END Expandable row styling */


        /* Search features */
        .table-header th {
            position: relative;
            padding-bottom: 30px; /* Make room for search input */
        }

        .column-search {
            position: absolute;
            bottom: 5px;
            left: 5px;
            right: 5px;
            padding: 4px;
            background: #333;
            border: 1px solid #444;
            color: white;
            border-radius: 3px;
            font-size: 12px;
            width: calc(100% - 5px);
        }

        .column-search::placeholder {
            color: #888;
        }
        /* End Search features */

    </style>
</head>

<body>
    <div id="directory-panel">
        <div class="search-container">
            <input type="text" id="directory-search" placeholder="Search files...">
        </div>
        <div class="directory-tree">
            <!-- Directory will be populated here -->
        </div>
    </div>
    <div id="viewer-container">

        <button id="toggle-table" class="table-toggle">Celltivity DB</button>

        <div id="table-list" class="table-list-container">
            <div class="table-header-container">
                <table class="table-list table-header-table">
                    <thead>
                        <tr class="table-header">
                            <th>Sample View</th>
                            <th>
                                Patient ID
                                <input type="text" class="column-search" data-column="1" placeholder="Search ...">
                            </th>
                            <th>
                                Date
                                <input type="text" class="column-search" data-column="2" placeholder="Search ...">
                            </th>
                            <th>Session</th>
                            <th>
                                Body Part
                                <input type="text" class="column-search" data-column="4" placeholder="Search ...">
                            </th>
                            <th>
                                Tool
                                <input type="text" class="column-search" data-column="5" placeholder="Search ...">
                            </th>
                            <th>Image</th>
                        </tr>
                    </thead>
                </table>
            </div>
            <div class="table-body-container">
                <table class="table-list">
                    <tbody id="table-body">
                        <!-- Table content will be populated by JavaScript -->
                    </tbody>
                </table>
            </div>
        </div>

        <div id="openseadragon1"></div>
        <div id="right-panel">
            <div class="control-section">
                <div class="section-title">Image Adjustments</div>
                <div class="control-group">
                    <div class="control-label">
                        <span>Brightness</span>
                        <span id="brightness-value">100%</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="brightness-slider" min="0" max="200" value="100">
                        <input type="number" id="brightness-number" value="100" min="0" max="200">
                    </div>
                </div>
                <div class="control-group">
                    <div class="control-label">
                        <span>Contrast</span>
                        <span id="contrast-value">100%</span>
                    </div>
                    <div class="slider-container">
                        <input type="range" id="contrast-slider" min="0" max="200" value="100">
                        <input type="number" id="contrast-number" value="100" min="0" max="200">
                    </div>
                </div>
                <button class="reset-button" id="reset-adjustments">Reset Adjustments</button>
            </div>
            <div class="invert-section">
                <div class="invert-control">
                    <input type="checkbox" id="invert-checkbox">
                    <label for="invert-checkbox">"H&E" color</label>
                </div>
            </div>
            
            <div class="edge-section">
                <div class="edge-title">Image Enhancement</div>
                <div class="edge-options">
                    <div class="edge-option">
                        <input type="radio" id="edge-none" name="edge-enhancement" value="none" checked>
                        <label for="edge-none">None (default)</label>
                    </div>
                    <div class="edge-option">
                        <input type="radio" id="edge-light" name="edge-enhancement" value="light">
                        <label for="edge-light">Light</label>
                    </div>
                    <div class="edge-option">
                        <input type="radio" id="edge-medium" name="edge-enhancement" value="medium">
                        <label for="edge-medium">Medium</label>
                    </div>
                    <div class="edge-option">
                        <input type="radio" id="edge-heavy" name="edge-enhancement" value="heavy">
                        <label for="edge-heavy">Heavy</label>
                    </div>
                </div>
            </div>

            <!--div class="measure-section">
                <div class="measure-title">Measurement</div>
                    <button id="toggle-measure" class="tool-button">Enable Measurement</button>
                </div>
            </div-->

        </div>

        <!-- Export context menu -->
        <div id="custom-context-menu" class="custom-context-menu">
            <!-- div class="context-menu-item" data-action="export-dicom">Export DICOM</div -->
            <div class="context-menu-item" data-action="left-compare">Select Left to Compare</div>
            <div class="context-menu-item" data-action="compare">Compare to Left</div>
            <div class="context-menu-item" data-action="export-png">Export Standard View (PNG)</div>            
        </div>

    </div>

    

    <!--script src="openseadragon/openseadragon.min.js"></script>
    <script src="openseadragon-scalebar.js"></script-->

    <script src="lib/openseadragon.min.js"></script>
    <script src="lib/openseadragon-annotorious.min.js"></script>
    <script src="lib/annotorious-shape-labels.min.js"></script>
    <script src="lib/fabricjs.min.js"></script>
    <script src="lib/openseadragon-fabricjs-overlay.js"></script>
    <script src="lib/dexie.min.js"></script>
    <script src="lib/openseadragon-scalebar.js"></script>
    <link rel="stylesheet" href="lib/annotorious.min.css">

    <!-- OSDMeasure classes -->
    <script src="js/OSDMeasure/src/controllers/DexieWrapper.js"></script>
    <script src="js/OSDMeasure/src/controllers/OSDMeasure.js"></script>
    <script src="js/OSDMeasure/src/models/Measurement.js"></script>
    <script src="js/OSDMeasure/src/models/Point.js"></script>
    <script src="js/OSDMeasure/src/views/ButtonBar.js"></script>
    <script src="js/OSDMeasure/src/views/MeasurementList.js"></script>
    <script src="js/OSDMeasure/src/views/MeasurementListItem.js"></script>
    <script src="js/OSDMeasure/src/views/Menu.js"></script>
    <script src="js/OSDMeasure/src/views/MenuButton.js"></script>
    <script src="js/OSDMeasure/src/views/UI.js"></script>

    <!-- Annotation logic -->
    <script src="js/AnnotationHelper.js"></script>

    <!-- DICOM utility >
    <script src="dicomParser.min.js"></script>
    <script src="dicomParser.js"></script>
    <script src="dicom-parser-util.js"></script-->


    <script>
        // Initialize viewer
        // 
        const viewer = OpenSeadragon({
            id: "openseadragon1",
            prefixUrl: "",
            tileSources: {
                type: 'image',
                url:  'SplashScreenNoBG.png',
                buildPyramid: false
            },
            showNavigator: true,
            animationTime: 0.5,
            blendTime: 0.1,
            constrainDuringPan: true,
            maxZoomPixelRatio: 2,
            minZoomImageRatio: 0.5,
            visibilityRatio: 0.5,
            zoomPerScroll: 1.2,

            showScalebar: true,
            showReferenceStrip: false,

            sequenceMode: true, 
            showSequenceControl: false, //disable usage, use reference strip 
            preserveViewport: true,
            useCanvas: true,
            preventDefaultAction: true
            
        });

        viewer.scalebar({
            type: OpenSeadragon.ScalebarType.MICROSCOPY,
            pixelsPerMeter: 1300000,
            minWidth: "50px",
            location: OpenSeadragon.ScalebarLocation.BOTTOM_RIGHT,
            xOffset: 10,
            yOffset: 10,
            stayInsideImage: true,
            color: "rgb(255, 255, 255)",
            fontColor: "rgb(255, 255, 255)",
            backgroundColor: "rgba(0, 0, 0, 0.8)",
            fontSize: "small",
            barThickness: 4
        });

        //Measurement Tool control
        let plugin = new OSDMeasure(viewer, {
            conversionFactor: 0.7, //0.7um per pixel
            units: "um",
            measurementColor : "rgba(255,255,0,1)",
            useBuiltInUI: false
        });

        //Annotation Tool control
        let annotationHelper = new AnnotationHelper(viewer);
        
        /* DICOM Logic --------*/
        //load dicom file directly
        /*const dicomUtil = new DicomParserUtil();

        async function loadAndParseDicom(filePath) {
            const result = await dicomUtil.loadFile(filePath);
            if (result.success) {
                console.log('Patient Info:', dicomUtil.getPatientInfo());
                console.log('Image Dimensions:', dicomUtil.getDimensions());
                console.log('Window Settings:', dicomUtil.getWindowSettings());
                
                // Get pixel value at specific coordinate
                const pixelValue = dicomUtil.getPixelValue(100, 100);
                console.log('Pixel Value at (100,100):', pixelValue);
                
                // Get display value after window/level adjustment
                console.log('Display Value:', dicomUtil.getDisplayValue(pixelValue));
            } else {
                console.error(result.message);
            }
        }

        loadAndParseDicom('IM0001.dcm');*/
        /* DICOM Logic END ---------- */

        // Directory structure : needs to update dynamically
        /*const directoryStructure = {
            'Celltivity Data': {
                type: 'folder',
                contents: {
                    'test_tissue.dzi': { type: 'file', path: 'test_tissue.dzi' },
                    'test_tissue2.dzi': { type: 'file', path: 'test_tissue2.dzi' },
                }
            }
        };*/

        function adjustTableColumnWidths() {
            const headerCells = document.querySelectorAll('.table-header-table th');
            const bodyCells = document.querySelectorAll('.table-body-container .table-list tbody tr:first-child td');
            
            // If no body cells yet, just return
            if (!bodyCells.length) return;
            
            // Get header cell widths
            const headerWidths = Array.from(headerCells).map(cell => cell.offsetWidth);
            
            // Apply fixed widths to both header and first row of body
            headerCells.forEach((cell, index) => {
                cell.style.width = `${headerWidths[index]}px`;
            });
            
            bodyCells.forEach((cell, index) => {
                if (index < headerWidths.length) {
                    cell.style.width = `${headerWidths[index]}px`;
                }
            });
        }
        
        // Call this after table is populated
        
        window.addEventListener('load', function() {
            // Set timeout to ensure table is rendered
            setTimeout(adjustTableColumnWidths, 100);
        });
        
        // Also call when table visibility changes
        document.getElementById('toggle-table').addEventListener('click', function() {
            setTimeout(adjustTableColumnWidths, 100);
        });


        // Update the loading function to use fetch API
        async function loadDirectoryFromListing() {
            try {
                //const response = await fetch('Celtivity Data Demo/Celtivity Data Demo/temp/listing_stacks_all.txt');
                const response = await fetch('Celtivity Data Demo/Celtivity Data Demo/temp/listing_thickness.txt');
                if (!response.ok) {
                    throw new Error(`HTTP error! status: ${response.status}`);
                }
                const text = await response.text();
                const lines = text.split('\n').filter(line => line.trim());
                
                // Initialize directory structure
                const structure = {
                    'Celtivity Data': {
                        type: 'folder',
                        contents: {}
                    }
                };

                // Process each line
                lines.forEach(line => {
                    const parts = line.split('|');
                    if (parts.length < 9) {
                        console.warn('Skipping malformed line:', line);
                        return;
                    }

                    const date = parts[1];
                    const patientId = parts[2];
                    const bodyPart = parts[3];
                    const tool = parts[4];
					const stackInfo = parts[5];
                    //read out stack thickness value
                    const stackThicknessInfo = parts[6];
                    const xcPath = parts[7];
                    const dziPath = parts[8].trim(); // Remove any trailing whitespace

                    // Extract stack value
                    const stackMatch = stackInfo.match(/stack=(\d+)/);
                    //const stackValue = stackMatch ? stackMatch[1] : '0';
                    const stackValue = stackMatch[1];

                    // Extract stack thickness value
                    const temp = stackThicknessInfo.match(/stack_thickness=(\d+)/);
                    const stackThickness = temp[1];

                    // Extract session number from dziPath
                    const sessionMatch = dziPath.match(/session_(\d+)/);
                    if (!sessionMatch) {
                        console.warn('Could not extract session number from:', dziPath);
                        return;
                    }
                    const session = sessionMatch[1];

                    // Extract image name from dziPath
                    const imageMatch = dziPath.match(/([^/]+)\.dzi$/);
                    if (!imageMatch) {
                        console.warn('Could not extract image name from:', dziPath);
                        return;
                    }
                    const imageName = imageMatch[1];

                    // Create date folder if it doesn't exist
                    if (!structure['Celtivity Data'].contents[date]) {
                        structure['Celtivity Data'].contents[date] = {
                            type: 'folder',
                            contents: {}
                        };
                    }

                    // Create patient folder if it doesn't exist
                    if (!structure['Celtivity Data'].contents[date].contents[patientId]) {
                        structure['Celtivity Data'].contents[date].contents[patientId] = {
                            type: 'folder',
                            contents: {
                                'OCT': {
                                    type: 'folder',
                                    contents: {}
                                }
                            }
                        };
                    }

                    // Create session folder if it doesn't exist
                    const sessionKey = `session ${session}`;
                    if (!structure['Celtivity Data'].contents[date].contents[patientId].contents['OCT'].contents[sessionKey]) {
                        structure['Celtivity Data'].contents[date].contents[patientId].contents['OCT'].contents[sessionKey] = {
                            type: 'folder',
                            contents: {}
                        };
                    }

                    // Add image file
                    structure['Celtivity Data'].contents[date].contents[patientId].contents['OCT'].contents[sessionKey].contents[imageName] = {
                        type: 'file',
                        path: dziPath,
                        bodyPart: bodyPart,
                        tool: tool,
                        xcPath: xcPath,
                        stackValue: stackValue,  // Add stack value to file metadata
                        stackThickness: stackThickness // Add stack thickness to file metadata
                    };
                });

                return structure;
            } catch (error) {
                console.error('Error loading directory structure:', error);
                throw error;
            }
        }


        // Create directory tree
        function createDirectoryTree(structure, parentElement) {
            for (const [name, item] of Object.entries(structure)) {
                const itemDiv = document.createElement('div');
                itemDiv.className = 'directory-item';

                if (item.type === 'folder') {
                    const toggleSpan = document.createElement('span');
                    toggleSpan.className = 'folder-toggle';
                    toggleSpan.textContent = '+';
                    itemDiv.appendChild(toggleSpan);

                    const iconSpan = document.createElement('span');
                    iconSpan.className = 'icon folder-icon';
                    itemDiv.appendChild(iconSpan);

                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = name;
                    itemDiv.appendChild(nameSpan);

                    const contentsDiv = document.createElement('div');
                    contentsDiv.className = 'folder-contents';
                    createDirectoryTree(item.contents, contentsDiv);

                    toggleSpan.onclick = (e) => {
                        e.stopPropagation();
                        contentsDiv.classList.toggle('open');
                        toggleSpan.textContent = contentsDiv.classList.contains('open') ? '-' : '+';
                        iconSpan.className = 'icon ' + (contentsDiv.classList.contains('open') ? 'folder-open-icon' : 'folder-icon');
                    };

                    parentElement.appendChild(itemDiv);
                    parentElement.appendChild(contentsDiv);
                } else {
                    const iconSpan = document.createElement('span');
                    iconSpan.className = 'icon file-icon';
                    itemDiv.appendChild(iconSpan);

                    const nameSpan = document.createElement('span');
                    nameSpan.textContent = name;
                    itemDiv.appendChild(nameSpan);

                    itemDiv.onclick = () => loadImage(item.path);
                    parentElement.appendChild(itemDiv);
                }
            }
        }

        // Load image function
        function loadImage(path) {
            if (path.endsWith('.dzi')) {
                //viewer.sequenceMode = true;
                //viewer.referenceStrip.element.style.display = 'none';
                //viewer.removeReferenceStrip();

                //remove existing depth annotations
                const existingAnnotations = document.getElementsByClassName('index-overlay');
                Array.from(existingAnnotations).forEach(ann => ann.remove());
        

                
                if (viewer.referenceStrip){
                    viewer.referenceStrip.element.style.display = 'none';
                };

                
                //viewer.clearControls();
                viewer.setControlsEnabled();

                //store currently opened image path (dzi) in global variable
                window.currentImagePath = path;

                viewer.open(path);
                viewer.viewport.goHome();
            };
        }

        // Load image depth stack
        function loadImageStack(tileSources, textLabels) {

            //remove existing depth annotations
            const existingAnnotations = document.getElementsByClassName('index-overlay');
            Array.from(existingAnnotations).forEach(ann => ann.remove());

            //store currently opened image path (dzi) in global variable
            window.currentImagePath = tileSources;

            viewer.open(tileSources);

            // Get dimensions
            const viewerWidth = viewer.element.offsetWidth;
            const viewerHeight = viewer.element.offsetHeight;
                // Calculate scaling factors
            const widthScale = viewerWidth / 900; // Base scale on 1920px width
            //const heightScale = viewerHeight / 1080; // Base scale on 1080px height
            //const scale = Math.min(widthScale, heightScale);

            for (let i = 0; i < tileSources.length; i++) {
                const indexOverlay = document.createElement('div');
                indexOverlay.className = 'index-overlay';
                indexOverlay.style.cssText = `
                    position: absolute;
                    bottom: 10px;
                    left: ${(200 * widthScale * i) + 10}px;
                    transform: translateY(-50%);
                    background: rgba(0, 0, 0, 0.7);
                    color: white;
                    padding: 5px 10px;
                    border-radius: 4px;
                    font-size: 14px;
                    z-index: 1000;
                `;
                    viewer.element.appendChild(indexOverlay);
                
                    //indexDisplay.style.left = Str(10 + i*40) + 'px';
                // Display current image index (1-based for user friendliness)

                    //textLabels[i]
                    let depthVal = Number(textLabels[i])*i;

                    indexOverlay.textContent = `Depth = ` + String(depthVal) + 'um';

                }
        }
        

        // Initialize directory
        //const directoryTreeElement = document.querySelector('.directory-tree');
        //createDirectoryTree(directoryStructure, directoryTreeElement);

        // Search functionality
        document.getElementById('directory-search').addEventListener('input', (e) => {
            const searchText = e.target.value.toLowerCase();
            document.querySelectorAll('.directory-item').forEach(item => {
                const text = item.textContent.toLowerCase();
                item.style.display = text.includes(searchText) ? '' : 'none';
            });
        });

        // Image adjustment controls
        const brightnessSlider = document.getElementById('brightness-slider');
        const contrastSlider = document.getElementById('contrast-slider');
        const brightnessNumber = document.getElementById('brightness-number');
        const contrastNumber = document.getElementById('contrast-number');
        const brightnessValue = document.getElementById('brightness-value');
        const contrastValue = document.getElementById('contrast-value');
        const resetButton = document.getElementById('reset-adjustments');
        const invertCheckbox = document.getElementById('invert-checkbox');

        //TODO : modify filtering going forward
        const edgeEnhancementLevels = {
            none: '',
            light: 'contrast(120%) url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\'><filter id=\'edge\'><feConvolveMatrix kernelMatrix=\'0 -1 0 -1 5 -1 0 -1 0\'/></filter></svg>#edge")',
            medium: 'contrast(140%) url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\'><filter id=\'edge\'><feConvolveMatrix kernelMatrix=\'0 -1 0 -1 5 -1 0 -1 0\'/></filter></svg>#edge")',
            heavy: 'contrast(180%) url("data:image/svg+xml;utf8,<svg xmlns=\'http://www.w3.org/2000/svg\'><filter id=\'edge\'><feConvolveMatrix kernelMatrix=\'0 -2 0 -2 9 -2 0 -2 0\'/></filter></svg>#edge")'
        };

        function updateImageFilters() {
            const brightness = parseFloat(brightnessSlider.value);
            const contrast = parseFloat(contrastSlider.value);
            const invert = invertCheckbox.checked ? 100 : 0;
            
            const selectedEdge = document.querySelector('input[name="edge-enhancement"]:checked').value;
            const edgeFilter = edgeEnhancementLevels[selectedEdge];
            
            const canvas = viewer.element.querySelector('.openseadragon-canvas');
            if (canvas) {
                canvas.style.filter = `brightness(${brightness}%) contrast(${contrast}%) invert(${invert}%) ${edgeFilter}`;
            }

            brightnessValue.textContent = `${brightness}%`;
            contrastValue.textContent = `${contrast}%`;
            brightnessNumber.value = brightness;
            contrastNumber.value = contrast;
        }

        // Event listeners
        brightnessSlider.addEventListener('input', updateImageFilters);
        contrastSlider.addEventListener('input', updateImageFilters);
        
        brightnessNumber.addEventListener('input', () => {
            const value = Math.min(Math.max(parseFloat(brightnessNumber.value) || 0, 0), 200);
            brightnessSlider.value = value;
            brightnessNumber.value = value;
            updateImageFilters();
        });

        contrastNumber.addEventListener('input', () => {
            const value = Math.min(Math.max(parseFloat(contrastNumber.value) || 0, 0), 200);
            contrastSlider.value = value;
            contrastNumber.value = value;
            updateImageFilters();
        });

        invertCheckbox.addEventListener('change', updateImageFilters);

       // Add event listeners for edge enhancement controls
        document.querySelectorAll('input[name="edge-enhancement"]').forEach(radio => {
            radio.addEventListener('change', updateImageFilters);
        });

        resetButton.addEventListener('click', () => {
            brightnessSlider.value = 100;
            contrastSlider.value = 100;
            brightnessNumber.value = 100;
            contrastNumber.value = 100;
            invertCheckbox.checked = false;
            document.getElementById('edge-none').checked = true;
            updateImageFilters();
        });


        // Add toggle button functionality
        /*
        const toggleButton = document.getElementById('toggle-measure');
        let isEnabled = false;

        toggleButton.addEventListener('click', function() {
            isEnabled = !isEnabled;
            if (isEnabled) {
                measure.enable();
                toggleButton.textContent = 'Disable Measurement';
                toggleButton.classList.add('active');
            } else {
                measure.disable();
                toggleButton.textContent = 'Enable Measurement';
                toggleButton.classList.remove('active');
            }
        });*/

        
        // Export functions
        function exportDicom(rowData) {
            console.log('Exporting DICOM for:', rowData);
            // Construct DICOM path
            const dicomPath = `Celtivity Data/DICOM/${rowData.date}/${rowData.patientId}/OCT/${rowData.session}/${rowData.imageName}.dcm`;
            
            // Here you would implement the actual DICOM export
            // For example:
            try {
                // This is a placeholder for actual export functionality
                alert(`Exporting DICOM file: ${dicomPath}`);

                //debug 
                //alert(`Stack value: ${rowData.session.stackInfo}');

                // You would typically trigger a download here
                // window.location.href = `/api/export/dicom?path=${encodeURIComponent(dicomPath)}`;
            } catch (error) {
                console.error('Error exporting DICOM:', error);
                alert('Error exporting DICOM file');
            }
        }

        function exportPng(rowData) {

            console.log('Exporting PNG for:', rowData);
            // Construct DICOM path
            const pngPath = `Celtivity Data/PNG/${rowData.date}/${rowData.patientId}/OCT/${rowData.session}/${rowData.imageName}.png`;
            
            // Here you would implement the actual DICOM export
            // For example:
            try {
                // This is a placeholder for actual export functionality
                alert(`Exporting PNG file: ${pngPath}`);

                //debug 
                //alert(`Stack value: ${rowData.session.stackInfo}');

                // You would typically trigger a download here
                // window.location.href = `/api/export/dicom?path=${encodeURIComponent(dicomPath)}`;
            } catch (error) {
                console.error('Error exporting PNG:', error);
                alert('Error exporting PNG file');
            }
            /*
            try {
                // Get the OpenSeadragon canvas
                const canvas = viewer.drawer.canvas;
                if (!canvas) {
                    throw new Error('Viewer canvas not found');
                }
        
                // Create timestamp for filename
                const now = new Date();
                const timestamp = now.getFullYear() +
                    ('0' + (now.getMonth() + 1)).slice(-2) +
                    ('0' + now.getDate()).slice(-2) + '_' +
                    ('0' + now.getHours()).slice(-2) +
                    ('0' + now.getMinutes()).slice(-2) +
                    ('0' + now.getSeconds()).slice(-2);
        
                // Extract directory path from the DZI path
                const dziPath = rowData.path;
                const pathParts = dziPath.split('/');
                pathParts.pop(); // Remove the DZI filename
                
                // Create export directory path
                const exportDirPath = [...pathParts, 'export'].join('/');
        
                // Convert canvas to data URL
                const dataUrl = canvas.toDataURL('image/png');
        
                // Create the filename with timestamp
                const filename = `capture_${timestamp}.png`;
                const fullPath = `${exportDirPath}/${filename}`;
        
                // Create export directory if it doesn't exist
                createDirectoryIfNotExists(exportDirPath).then(() => {
                    // Save the file using fetch
                    fetch(dataUrl)
                        .then(res => res.blob())
                        .then(blob => {
                            const formData = new FormData();
                            formData.append('file', blob, filename);
                            formData.append('path', exportDirPath);
        
                            // Send to server endpoint for saving
                            return fetch('/api/save-png', {
                                method: 'POST',
                                body: formData
                            });
                        })
                        .then(response => {
                            if (!response.ok) {
                                throw new Error('Failed to save PNG');
                            }
                            console.log(`PNG saved successfully to: ${fullPath}`);
                            alert(`Image exported to: ${fullPath}`);
                        })
                        .catch(error => {
                            console.error('Error saving PNG:', error);
                            alert('Error saving PNG file. Check console for details.');
                        });
                });
        
            } catch (error) {
                console.error('Error exporting PNG:', error);
                alert('Error generating PNG file. Check console for details.');
            }*/
        }
        
        // Helper function to create directory
        /*async function createDirectoryIfNotExists(dirPath) {
            try {
                const response = await fetch('/api/create-directory', {
                    method: 'POST',
                    headers: {
                        'Content-Type': 'application/json'
                    },
                    body: JSON.stringify({ path: dirPath })
                });
        
                if (!response.ok) {
                    throw new Error('Failed to create directory');
                }
        
                return await response.json();
            } catch (error) {
                alert('Error creating directory:', error);
                throw error;
            }
        }*/



        function compareTwo(currentPath, selectedPath, currentSettings, selectedSettings) {
            // Create URL with parameters
            const params = new URLSearchParams({
                img1: currentPath,
                img2: selectedPath,
                settings1: JSON.stringify(currentSettings),
                settings2: JSON.stringify(selectedSettings)
            });
            
            const compareUrl = `viewer_twoup_page.html?${params.toString()}`;
            
            // Open in new window with specific size
            const width = Math.min(1200, window.screen.width);
            const height = Math.min(800, window.screen.height);
            const left = (window.screen.width - width) / 2;
            const top = (window.screen.height - height) / 2;
            
            window.open(compareUrl, 'compareViewer',
                `width=${width},height=${height},left=${left},top=${top}`);
        }
        

        //Assign background colors to session IDs 
        function getSessionColor(sessionId) {
            // Define a set of muted, professional colors for alternating sessions
            const colors = [
                //'rgba(156, 39, 176, 0.1)',  // Purple
                //'rgba(255, 152, 0, 0.1)',   // Orange
                //'rgba(233, 30, 99, 0.1)',   // Pink
                'rgba(0, 188, 212, 0.1)',   // Cyan
                'rgba(121, 85, 72, 0.1)',    // Brown
                'rgba(63, 81, 181, 0.1)',    // Indigo
                'rgba(139, 195, 74, 0.1)',   // Light Green
                'rgba(103, 58, 183, 0.1)',   // Deep Purple
                'rgba(255, 87, 34, 0.1)',    // Deep Orange
                'rgba(3, 169, 244, 0.1)',    // Light Blue
                'rgba(0, 150, 136, 0.1)',    // Teal
                'rgba(158, 158, 158, 0.1)',   // Grey        
                'rgba(33, 150, 243, 0.1)',  // Blue
                'rgba(76, 175, 80, 0.1)',   // Green        
            ];
            
            // Extract session number and use it to pick a color
            const sessionNum = parseInt(sessionId.match(/\d+/)[0]);
            return colors[sessionNum % colors.length];
        }        


        // Update the groupDataByPatientAndSession function
        function groupDataByPatientAndSession(data) {
            const grouped = {};
            data.forEach(item => {
                // Use date as primary key, then patientId
                const key = `${item.date}/${item.patientId}`;
                if (!grouped[key]) {
                    grouped[key] = {
                        date: item.date,
                        patientId: item.patientId,
                        bodyPart: item.bodyPart,
                        sessions: {}
                    };
                }
                if (!grouped[key].sessions[item.session]) {
                    grouped[key].sessions[item.session] = [];
                }
                grouped[key].sessions[item.session].push(item);
            });
            return grouped;
        }

        // Update the extractData function
        function extractData(structure, parentPath = '') {
            let data = [];
    
            // Start with Celtivity Data contents (dates are here)
            const celtivityData = structure['Celtivity Data'].contents;
            
            // Iterate through dates
            for (const [date, dateContent] of Object.entries(celtivityData)) {
                if (dateContent.type === 'folder') {
                    // Iterate through patients under each date
                    for (const [patientId, patientContent] of Object.entries(dateContent.contents)) {
                        if (patientContent.type === 'folder') {
                            // Get OCT folder
                            const octContent = patientContent.contents['OCT'];
                            if (octContent && octContent.type === 'folder') {
                                // Iterate through sessions
                                for (const [sessionKey, sessionContent] of Object.entries(octContent.contents)) {
                                    if (sessionContent.type === 'folder') {
                                        // Iterate through images in session
                                        for (const [imageName, imageContent] of Object.entries(sessionContent.contents)) {
                                            if (imageContent.type === 'file') {
                                                data.push({
                                                    date: date,
                                                    patientId: patientId,
                                                    session: sessionKey,
                                                    imageName: imageName,
                                                    bodyPart: imageContent.bodyPart,
                                                    toolName: imageContent.tool,
                                                    path: imageContent.path,
                                                    xcPath: imageContent.xcPath,
                                                    stackValue: imageContent.stackValue,
                                                    stackThickness: imageContent.stackThickness  
                                                });
                                            }
                                        }
                                    }
                                }
                            }
                        }
                    }
                }
            }
            return data;
        }

        function createTableList(dirStruct) {
            const tableBody = document.getElementById('table-body');
            const toggleButton = document.getElementById('toggle-table');
            const tableList = document.getElementById('table-list');
        
            // Function to extract and organize data from directoryStructure
            /*function extractData(structure, parentPath = '') {
                let data = [];
                
                for (const [name, item] of Object.entries(structure)) {
                    if (item.type === 'folder') {
                        const newPath = parentPath ? `${parentPath}/${name}` : name;
                        data = data.concat(extractData(item.contents, newPath));
                    } else if (item.type === 'file') {
                        const pathParts = item.path.split('/');
                        const date = pathParts[2];
                        const patientId = pathParts[3];
                        const session = pathParts[5];
                        const imageName = pathParts[6].split('.')[0];
                        
                        data.push({
                            patientId,
                            session,
                            date,
                            bodyPart: item.bodyPart,
                            toolName: item.tool,
                            imageName,
                            path: item.path,
                            xcPath: item.xcPath
                        });
                    }
                }
                return data;
            }
        */
            // Extract data from directoryStructure
            //const tableData = extractData(dirStruct);
        
            //const groupedData = groupDataByPatientAndSession(tableData);

            // Function to group data by patient and session
            /*function groupDataByPatientAndSession(data) {
                const grouped = {};
                data.forEach(item => {
                    const key = `${item.patientId}-${item.date}-${item.bodyPart}`;
                    if (!grouped[key]) {
                        grouped[key] = {
                            patientId: item.patientId,
                            date: item.date,
                            bodyPart: item.bodyPart,
                            sessions: {}
                        };
                    }
                    if (!grouped[key].sessions[item.session]) {
                        grouped[key].sessions[item.session] = [];
                    }
                    grouped[key].sessions[item.session].push(item);
                });
                return grouped;
            }
            */

            // Extract and group data
            const tableData = extractData(dirStruct);
            
            // Group data by date and patient
            const groupedData = {};
            tableData.forEach(item => {
                const dateKey = item.date;
                const patientKey = item.patientId;
                
                if (!groupedData[dateKey]) {
                    groupedData[dateKey] = {};
                }
                if (!groupedData[dateKey][patientKey]) {
                    groupedData[dateKey][patientKey] = {
                        sessions: {}
                    };
                }
                
                const sessionKey = item.session;
                if (!groupedData[dateKey][patientKey].sessions[sessionKey]) {
                    groupedData[dateKey][patientKey].sessions[sessionKey] = [];
                }
                groupedData[dateKey][patientKey].sessions[sessionKey].push(item);
            });

            //const groupedData = groupDataByPatientAndSession(tableData);

            // Populate table
               // Clear existing table content
            tableBody.innerHTML = '';

            // Create table rows
            Object.entries(groupedData).forEach(([date, patients]) => {
                Object.entries(patients).forEach(([patientId, data]) => {
                    const sessionCount = Object.keys(data.sessions).length;
                    const hasMultipleSessions = sessionCount > 1;
        
                    if (hasMultipleSessions) {
                        // Create parent row
                        const firstSession = Object.values(data.sessions)[0][0];
                        const parentRow = document.createElement('tr');
                        parentRow.className = 'parent-row';
                        const groupId = `group-${date}-${patientId}`.replace(/\s+/g, '-');
        
                        parentRow.innerHTML = `
                            <td>
                                <div class="thumbnail-container">
                                    <span class="expand-button" data-group="${groupId}">+</span>
                                    <img src="${firstSession.xcPath}" alt="Thumbnail" 
                                         onerror="this.src='placeholder.png'; this.onerror=null;">
                                </div>
                            </td>
                            <td>${patientId}</td>
                            <td>${date}</td>
                            <td>Multiple (${sessionCount})</td>
                            <td>${firstSession.bodyPart}</td>
                            <td>${firstSession.toolName}</td>
                            <td>Multiple</td>
                        `;
        
                        tableBody.appendChild(parentRow);
        
                        // Add nested rows for each session
                        Object.entries(data.sessions).forEach(([session, images], sessionIndex) => {


                            // Group stacked images
                            const hasStackedImages = images.some(img => img.stackValue === '1');
    
                           

                            if (hasStackedImages) {
                                
                                //alert(`Has stacks: ${hasStackedImages}`);
                                // Create a single row for all stacked images
                                const tileSources = images.map(img => img.path);
                                const firstImage = images[0];
                                
                                const nestedRow = document.createElement('tr');
                                nestedRow.className = 'nested-row';
                                nestedRow.setAttribute('data-group', groupId);
                                nestedRow.setAttribute('data-path', tileSources);  // Store all paths
                                nestedRow.setAttribute('data-is-stack', 'true');  // Mark as stack
                                nestedRow.style.backgroundColor = getSessionColor(sessionIndex.toString());

                                nestedRow.innerHTML = `
                                    <td>
                                        <div class="thumbnail-container">
                                            <img src="${firstImage.xcPath}" alt="Stack thumbnail" 
                                                onerror="this.src='placeholder.png'; this.onerror=null;">
                                        </div>
                                    </td>
                                    <td>${firstImage.patientId}</td>
                                    <td>${firstImage.date}</td>
                                    <td>${firstImage.session}</td>
                                    <td>${firstImage.bodyPart}</td>
                                    <td>${firstImage.toolName}</td>
                                    <td>Stack (${tileSources.length} images)</td>
                                `;

                                const stackDepths = images.map(img => img.stackThickness);

                                //nestedRow.addEventListener('click', () => viewer.open(tileSources));
                                nestedRow.addEventListener('click', () => loadImageStack(tileSources, stackDepths));
                                viewer.addReferenceStrip();
                                viewer.viewport.goHome();



                                tableBody.appendChild(nestedRow);
                            }

                            else {
                                images.forEach(image => {
                                    const nestedRow = document.createElement('tr');
                                    nestedRow.className = 'nested-row';
                                    nestedRow.setAttribute('data-group', groupId);
                                    nestedRow.setAttribute('data-path', image.path);
                                    nestedRow.style.backgroundColor = getSessionColor(sessionIndex.toString());
            
                                    nestedRow.innerHTML = `
                                        <td>
                                            <div class="thumbnail-container">
                                                <img src="${image.xcPath}" alt="Thumbnail for ${image.imageName}" 
                                                    onerror="this.src='placeholder.png'; this.onerror=null;">
                                            </div>
                                        </td>
                                        <td>${image.patientId}</td>
                                        <td>${image.date}</td>
                                        <td>${image.session}</td>
                                        <td>${image.bodyPart}</td>
                                        <td>${image.toolName}</td>
                                        <td>${image.imageName}</td>
                                    `;

                                    nestedRow.addEventListener('click', () => loadImage(image.path));
                                    tableBody.appendChild(nestedRow);
                                });
                            }
                        });
        
                        // Add expand/collapse functionality
                        const expandButton = parentRow.querySelector('.expand-button');
                        expandButton.addEventListener('click', (e) => {
                            e.stopPropagation();
                            const isExpanded = expandButton.textContent === '-';
                            expandButton.textContent = isExpanded ? '+' : '-';
                            
                            const groupRows = document.querySelectorAll(`tr.nested-row[data-group="${groupId}"]`);
                            groupRows.forEach(row => {
                                row.classList.toggle('visible');
                            });
                        });
        
                    } else {
                        // Single session - create normal rows
                        const images = Object.values(data.sessions)[0];
                        images.forEach(image => {
                            const row = document.createElement('tr');
                            row.setAttribute('data-path', image.path);
                            
                            row.innerHTML = `
                                <td>
                                    <div class="thumbnail-container">
                                        <img src="${image.xcPath}" alt="Thumbnail for ${image.imageName}" 
                                             onerror="this.src='placeholder.png'; this.onerror=null;">
                                    </div>
                                </td>
                                <td>${image.patientId}</td>
                                <td>${image.date}</td>
                                <td>${image.session}</td>
                                <td>${image.bodyPart}</td>
                                <td>${image.toolName}</td>
                                <td>${image.imageName}</td>
                            `;
        
                            row.addEventListener('click', () => loadImage(image.path));
                            tableBody.appendChild(row);
                        });
                    }
                });
            });
        
            // Toggle table visibility
            toggleButton.addEventListener('click', () => {
                const isVisible = tableList.style.display === 'block';
                tableList.style.display = isVisible ? 'none' : 'block';
                toggleButton.textContent = isVisible ? 'Open DB' : 'Close DB';
            });
        }

        function createNestedRow(image, groupId) {
            const nestedRow = document.createElement('tr');
            nestedRow.className = 'nested-row';
            nestedRow.setAttribute('data-group', groupId);
            nestedRow.setAttribute('data-path', image.path);
            
            nestedRow.innerHTML = `
                <td>
                    <div class="thumbnail-container">
                        <img src="${image.xcPath}" alt="Thumbnail for ${image.imageName}" 
                             onerror="this.src='placeholder.png'; this.onerror=null;">
                    </div>
                </td>
                <td>${image.patientId}</td>
                <td>${image.date}</td>
                <td>${image.session}</td>
                <td>${image.bodyPart}</td>
                <td>${image.toolName}</td>
                <td>${image.imageName}</td>
            `;
            
            nestedRow.addEventListener('click', () => loadImage(image.path));
            return nestedRow;
        }
        
        function createSingleRow(image) {
            const row = document.createElement('tr');
            row.setAttribute('data-path', image.path);
            
            row.innerHTML = `
                <td>
                    <div class="thumbnail-container">
                        <img src="${image.xcPath}" alt="Thumbnail for ${image.imageName}" 
                             onerror="this.src='placeholder.png'; this.onerror=null;">
                    </div>
                </td>
                <td>${image.patientId}</td>
                <td>${image.date}</td>
                <td>${image.session}</td>
                <td>${image.bodyPart}</td>
                <td>${image.toolName}</td>
                <td>${image.imageName}</td>
            `;
            
            row.addEventListener('click', () => loadImage(image.path));
            return row;
        }
        
        function addExpandCollapseHandler(parentRow, groupId) {
            const expandButton = parentRow.querySelector('.expand-button');
            expandButton.addEventListener('click', (e) => {
                e.stopPropagation();
                const isExpanded = expandButton.textContent === '-';
                expandButton.textContent = isExpanded ? '+' : '-';
                
                const groupRows = document.querySelectorAll(`tr.nested-row[data-group="${groupId}"]`);
                groupRows.forEach(row => {
                    row.classList.toggle('visible');
                });
            });
        }


        function initializeTableSearch() {
            const tableBody = document.getElementById('table-body');
            const searchInputs = document.querySelectorAll('.column-search');
            let searchStates = {};
        
            // Function to check if a row matches search criteria
            function rowMatchesSearch(row) {
                for (const [column, searchValue] of Object.entries(searchStates)) {
                    if (!searchValue) continue;
                    const cellValue = row.cells[column].textContent.toLowerCase();
                    if (!cellValue.includes(searchValue.toLowerCase())) {
                        return false;
                    }
                }
                return true;
            }
        
            function filterTable() {
                const rows = tableBody.getElementsByTagName('tr');
                const groupMatches = new Map(); // Track which groups have matching content
        
                // First pass: Check which groups have matching content
                for (let row of rows) {
                    const matches = rowMatchesSearch(row);
                    
                    if (row.classList.contains('parent-row')) {
                        const groupId = row.querySelector('.expand-button').getAttribute('data-group');
                        groupMatches.set(groupId, matches);
                    } else if (row.classList.contains('nested-row')) {
                        const groupId = row.getAttribute('data-group');
                        if (matches) {
                            groupMatches.set(groupId, true);
                        }
                    }
                }
        
                // Second pass: Apply visibility
                // Note: nested rows are handled by parent row 
                for (let row of rows) {
                    if (row.classList.contains('parent-row')) {
                        const groupId = row.querySelector('.expand-button').getAttribute('data-group');
                        const shouldShow = groupMatches.get(groupId);
                        row.style.display = shouldShow ? '' : 'none';
                        
                        // Reset expand button state for visible parent rows
                        if (shouldShow) {
                            const expandButton = row.querySelector('.expand-button');
                            expandButton.addEventListener('click', (e) => {
                                e.stopPropagation();
                                const isExpanded = expandButton.textContent === '-';
                                expandButton.textContent = isExpanded ? '-' : '+';
                                
                                const groupRows = document.querySelectorAll(`tr.nested-row[data-group="${groupId}"]`);
                                groupRows.forEach(r => {
                                    r.classList.toggle('visible', isExpanded);
                                });

                            });
                        }

                    } else {
                        // Regular row
                        row.style.display = rowMatchesSearch(row) ? '' : 'none';
                    }
                }        
            }
        
            // Add event listeners to search inputs
            searchInputs.forEach(input => {
                input.addEventListener('input', (e) => {
                    const column = e.target.getAttribute('data-column');
                    searchStates[column] = e.target.value;
                    filterTable();
                });
        
                // Prevent propagation of clicks on search inputs
                input.addEventListener('click', (e) => {
                    e.stopPropagation();
                });
            });
        
            // Add clear functionality
            const clearSearches = () => {
                searchInputs.forEach(input => {
                    input.value = '';
                });
                searchStates = {};
                filterTable();
            };
        
            // Export clear function if needed elsewhere
            window.clearTableSearches = clearSearches;
        }

        // Export : Update the initializeContextMenu function
        function initializeContextMenu() {
            const contextMenu = document.getElementById('custom-context-menu');
            const tableContainer = document.getElementById('table-list');
            let selectedRow = null;
        
            // Hide context menu on click outside
            document.addEventListener('click', () => {
                contextMenu.style.display = 'none';
                if (selectedRow) {
                    selectedRow.classList.remove('selected');
                }
            });
        
            // Prevent default context menu and handle right-click
            tableContainer.addEventListener('contextmenu', (e) => {
                e.preventDefault();
                
                const row = e.target.closest('tr');
                if (!row || !row.hasAttribute('data-path')) return;
        
                // Remove previous selection
                if (selectedRow) {
                    selectedRow.classList.remove('selected');
                }
        
                // Add selected state to current row
                selectedRow = row;
                row.classList.add('selected');

                
                // Capture current settings
                const currentSettings = {
                    brightness: parseInt(document.getElementById('brightness-slider').value),
                    contrast: parseInt(document.getElementById('contrast-slider').value),
                    invert: document.getElementById('invert-checkbox').checked,
                    edgeFilter: document.querySelector('input[name="edge-enhancement"]:checked').value
                };

        
                // Default settings for selected image
                const selectedSettings = {
                    brightness: 100,
                    contrast: 100,
                    invert: false,
                    edgeFilter: 'none'
                };

                // Get row data
                const rowData = {
                    patientId: row.cells[1].textContent,
                    date: row.cells[2].textContent,
                    session: row.cells[3].textContent,
                    imageName: row.cells[6].textContent,
                    path: row.getAttribute('data-path'),
                    currentSettings: currentSettings,
                    selectedSettings: selectedSettings
                };

                // Store row data for context menu actions
                contextMenu.setAttribute('data-row-info', JSON.stringify(rowData));
        
                // Calculate menu position
                const menuWidth = 150; // Approximate menu width
                const menuHeight = 80; // Approximate menu height
                const containerRect = tableContainer.getBoundingClientRect();
                const scrollTop = tableContainer.scrollTop;
                const scrollLeft = tableContainer.scrollLeft;
        
                // Position relative to click point
        
                //Display at top right of the click position
                let x = e.clientX;  
                let y = e.clientY - menuHeight;
        
                // Position the menu
                contextMenu.style.display = 'block';
                contextMenu.style.left = `${x}px`;
                contextMenu.style.top = `${y}px`;
            });
        
            // Rest of the event handlers remain the same
            contextMenu.addEventListener('click', (e) => {
                const action = e.target.getAttribute('data-action');
                if (!action) return;
        
                const rowData = JSON.parse(contextMenu.getAttribute('data-row-info'));
        
                switch (action) {
                    case 'export-dicom':
                        exportDicom(rowData);
                        break;
                    case 'export-png':
                        exportPng(rowData);
                        break;
                    case 'left-compare':
                        //Set left image for comparison
                        window.leftCompareImagePath = rowData.path;
                        break;
                    case 'compare':
                        // Get currently viewed image path from the viewer
                        
                        //handle depth stacks - parse out "zeroth" image in the stack
                        if (window.leftCompareImagePath == undefined){
                            alert('Please Select Left Image to Compare');
                            break;
                        }

                        const currentImagePath = window.leftCompareImagePath;
                    
                        const newImagePath = rowData.path;

                        if (currentImagePath) {
                            compareTwo(newImagePath, currentImagePath,  
                            rowData.selectedSettings,
                            rowData.currentSettings);
                        } else {
                            alert('Please Select Left Image to Compare');
                        }
                        break;
                }

                contextMenu.style.display = 'none';
                if (selectedRow) {
                    selectedRow.classList.remove('selected');
                }
            });
        
            contextMenu.addEventListener('click', (e) => {
                e.stopPropagation();
            });
        
            document.addEventListener('keydown', (e) => {
                if (e.key === 'Escape') {
                    contextMenu.style.display = 'none';
                    if (selectedRow) {
                        selectedRow.classList.remove('selected');
                    }
                }
            });
        }
        

        // Update the initialization function
        async function initializeViewer() {
            try {
                // Show loading state if needed
                // document.getElementById('loading-indicator')?.style.display = 'block';
                
                const loadedStructure = await loadDirectoryFromListing();
                if (loadedStructure) {
                    // Update the global directoryStructure
                    window.directoryStructure = loadedStructure;
                    
                    // Initialize directory tree
                    const directoryTreeElement = document.querySelector('.directory-tree');
                    createDirectoryTree(loadedStructure, directoryTreeElement);
                    
                    // Initialize table list
                    createTableList(loadedStructure);

                    //add to support sortable/searchable columns
                    //initializeTableSorting();

                    initializeContextMenu();

                    //add search capability
                    initializeTableSearch();

                } else {
                    console.error('Failed to load directory structure');
                    alert('Failed to load directory structure. Please try again.');
                }
            } catch (error) {
                console.error('Error initializing viewer:', error);
                alert(error);
            } finally {
                // Hide loading state if needed
                // document.getElementById('loading-indicator')?.style.display = 'none';
            }
        }

        // Initialize when document is ready
        document.addEventListener('DOMContentLoaded', initializeViewer);

    </script>
</body>
</html>